package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

type trainer struct {
	client       *http.Client
	baseURL      string
	pollInterval time.Duration
	logger       *log.Logger
	totalBoards  int
}

type statusResponse struct {
	Status string `json:"status"`
}

type queueResponse struct {
	TotalInQueue int `json:"total_in_queue"`
}

type ttCacheStatusResponse struct {
	Count    int     `json:"count"`
	Capacity int     `json:"capacity"`
	Usage    float64 `json:"usage"`
	Full     bool    `json:"full"`
}

func main() {
	logger, closeLog, err := buildLogger("/logs/AITrainer.log")
	if err != nil {
		log.Fatalf("failed to initialize logger: %v", err)
	}
	defer closeLog()

	baseURL := getenv("BACKEND_URL", "http://backend:8080")
	pollMs := getenvInt("POLL_INTERVAL_MS", 2000)
	t := &trainer{
		client: &http.Client{
			Timeout: 10 * time.Second,
		},
		baseURL:      baseURL,
		pollInterval: time.Duration(pollMs) * time.Millisecond,
		logger:       logger,
	}

	t.logf("AI trainer started. backend=%s poll_interval=%s", t.baseURL, t.pollInterval)

	if err := t.waitBackendReady(); err != nil {
		t.logf("Backend did not become ready: %v", err)
		os.Exit(1)
	}

	if err := t.run(); err != nil {
		t.logf("Trainer stopped with error: %v", err)
		os.Exit(1)
	}

	t.logf("Trainer stopped cleanly. Total boards sent to analyze: %d", t.totalBoards)
}

func buildLogger(path string) (*log.Logger, func(), error) {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return nil, nil, err
	}
	f, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)
	if err != nil {
		return nil, nil, err
	}
	logger := log.New(io.MultiWriter(os.Stdout, f), "", 0)
	return logger, func() { _ = f.Close() }, nil
}

func (t *trainer) run() error {
	for {
		full, err := t.ttIsFull()
		if err != nil {
			return err
		}
		if full {
			t.logf("TT cache is full. Stopping trainer.")
			return nil
		}

		queueBefore, err := t.getQueueCount()
		if err != nil {
			return err
		}

		if err := t.startAIVsAIGame(); err != nil {
			return err
		}
		t.logf("Started a game")
		t.logf("Waiting the game to finish...")

		for {
			full, err := t.ttIsFull()
			if err != nil {
				return err
			}
			if full {
				t.logf("TT cache is full during game. Stopping trainer.")
				_ = t.stopGame()
				return nil
			}

			running, err := t.gameRunning()
			if err != nil {
				return err
			}
			if !running {
				break
			}
			time.Sleep(t.pollInterval)
		}

		t.logf("Game is over.")
		t.logf("Waiting the analyze queue to be empty...")

		queueAfterGame, err := t.getQueueCount()
		if err != nil {
			return err
		}
		newBoards := queueAfterGame - queueBefore
		if newBoards < 0 {
			newBoards = 0
		}
		t.totalBoards += newBoards

		lastLogged := -1
		for {
			full, err := t.ttIsFull()
			if err != nil {
				return err
			}
			if full {
				t.logf("TT cache is full while queue is draining. Stopping trainer.")
				return nil
			}

			count, err := t.getQueueCount()
			if err != nil {
				return err
			}
			if count == 0 {
				t.logf("Queue is empty.")
				break
			}
			if count != lastLogged {
				t.logf("%d boards still in queue..", count)
				lastLogged = count
			}
			time.Sleep(t.pollInterval)
		}

		t.logf("Boards sent to analyze this game: %d (total: %d)", newBoards, t.totalBoards)
		if newBoards == 0 {
			t.logf("No new boards were generated by the last game. Stopping trainer to avoid spam.")
			return nil
		}
	}
}

func (t *trainer) waitBackendReady() error {
	deadline := time.Now().Add(60 * time.Second)
	for time.Now().Before(deadline) {
		if err := t.ping(); err == nil {
			return nil
		}
		time.Sleep(1 * time.Second)
	}
	return fmt.Errorf("timeout after 60s")
}

func (t *trainer) ping() error {
	req, err := http.NewRequest(http.MethodGet, t.baseURL+"/api/ping", nil)
	if err != nil {
		return err
	}
	resp, err := t.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("ping status %d", resp.StatusCode)
	}
	return nil
}

func (t *trainer) startAIVsAIGame() error {
	payload := map[string]any{
		"settings": map[string]any{
			"mode":         "ai_vs_ai",
			"human_player": 1,
		},
	}
	return t.postJSON("/api/start", payload, nil)
}

func (t *trainer) stopGame() error {
	return t.postJSON("/api/stop", map[string]any{}, nil)
}

func (t *trainer) gameRunning() (bool, error) {
	var status statusResponse
	if err := t.getJSON("/api/status", &status); err != nil {
		return false, err
	}
	return status.Status == "running", nil
}

func (t *trainer) getQueueCount() (int, error) {
	var queue queueResponse
	if err := t.getJSON("/api/analitics/queue", &queue); err != nil {
		return 0, err
	}
	return queue.TotalInQueue, nil
}

func (t *trainer) ttIsFull() (bool, error) {
	var tt ttCacheStatusResponse
	if err := t.getJSON("/api/cache/tt", &tt); err != nil {
		return false, err
	}
	return tt.Full, nil
}

func (t *trainer) getJSON(path string, out any) error {
	req, err := http.NewRequest(http.MethodGet, t.baseURL+path, nil)
	if err != nil {
		return err
	}
	resp, err := t.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return fmt.Errorf("GET %s -> %d: %s", path, resp.StatusCode, string(body))
	}
	return json.NewDecoder(resp.Body).Decode(out)
}

func (t *trainer) postJSON(path string, payload any, out any) error {
	body, err := json.Marshal(payload)
	if err != nil {
		return err
	}
	req, err := http.NewRequest(http.MethodPost, t.baseURL+path, bytes.NewReader(body))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := t.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		respBody, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return fmt.Errorf("POST %s -> %d: %s", path, resp.StatusCode, string(respBody))
	}
	if out == nil {
		return nil
	}
	return json.NewDecoder(resp.Body).Decode(out)
}

func (t *trainer) logf(format string, args ...any) {
	ts := time.Now().Format("2006-01-02 15:04:05")
	t.logger.Printf("[%s] %s", ts, fmt.Sprintf(format, args...))
}

func getenv(key, fallback string) string {
	value := os.Getenv(key)
	if value == "" {
		return fallback
	}
	return value
}

func getenvInt(key string, fallback int) int {
	value := os.Getenv(key)
	if value == "" {
		return fallback
	}
	var parsed int
	if _, err := fmt.Sscanf(value, "%d", &parsed); err != nil || parsed <= 0 {
		return fallback
	}
	return parsed
}
